import java.sql.*;
import utils.DBConnection;

/**
 * SchemaInitializer ensures required database objects exist before the
 * application proceeds. It is idempotent: safe to run multiple times.
 */
public class SchemaInitializer {

    public static void initialize() {
        try (Connection conn = DBConnection.getConnection()) {
            conn.setAutoCommit(true); // keep default autocommit

            ensurePlansTable(conn);
            ensureCustomersTable(conn);
            ensureBillingTable(conn);
            ensureUsageTable(conn);
            ensureRechargesTable(conn);
            ensureSpamFraudTables(conn);
            ensureSupportTicketsTable(conn);
            ensureTicketCommentsTable(conn);
            ensureScheduledPlanChangesTable(conn);
            seedPlans(conn);
        } catch (SQLException e) {
            System.err.println("Schema initialization failed: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static boolean tableExists(Connection conn, String tableName) throws SQLException {
        String sql = "SELECT COUNT(*) FROM user_tables WHERE table_name = ?";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setString(1, tableName.toUpperCase());
            try (ResultSet rs = ps.executeQuery()) {
                return rs.next() && rs.getInt(1) > 0;
            }
        }
    }

    // Postpaid: schedule plan changes for next billing cycle
    private static void ensureScheduledPlanChangesTable(Connection conn) throws SQLException {
        if (tableExists(conn, "SCHEDULED_PLAN_CHANGES")) return;
        String ddl = "CREATE TABLE SCHEDULED_PLAN_CHANGES (" +
                "ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY, " +
                "CUSTOMER_ID NUMBER NOT NULL, " +
                "NEW_PLAN_ID NUMBER NOT NULL, " +
                "CHANGE_TYPE VARCHAR2(10) NOT NULL, " + // UPGRADE or DOWNGRADE
                "EFFECTIVE_MONTH VARCHAR2(6) NOT NULL, " + // YYYYMM
                "REQUESTED_AT DATE DEFAULT SYSDATE NOT NULL, " +
                "CONSTRAINT FK_SPC_CUSTOMER FOREIGN KEY (CUSTOMER_ID) REFERENCES CUSTOMERS(CUSTOMER_ID) ON DELETE CASCADE, " +
                "CONSTRAINT FK_SPC_PLAN FOREIGN KEY (NEW_PLAN_ID) REFERENCES PLANS(PLAN_ID) ON DELETE CASCADE" +
                ")";
        try (Statement st = conn.createStatement()) {
            st.executeUpdate(ddl);
            System.out.println("Created table SCHEDULED_PLAN_CHANGES");
        }
    }

    private static boolean isEmpty(Connection conn, String tableName) throws SQLException {
        String sql = "SELECT 1 FROM " + tableName + " FETCH FIRST 1 ROWS ONLY";
        try (Statement st = conn.createStatement(); ResultSet rs = st.executeQuery(sql)) {
            return !rs.next();
        } catch (SQLException e) {
            // if table missing treat as empty
            return true;
        }
    }

    private static void ensurePlansTable(Connection conn) throws SQLException {
        if (!tableExists(conn, "PLANS")) {
            String ddl = "CREATE TABLE PLANS (" +
                    "PLAN_ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY, " +
                    "PLAN_NAME VARCHAR2(100) NOT NULL, " +
                    // New: plan type to distinguish prepaid vs postpaid
                    "PLAN_TYPE VARCHAR2(10) DEFAULT 'POSTPAID' NOT NULL, " +
                    // Postpaid billing fields
                    "MONTHLY_RENT NUMBER(10,2), " +
                    "CALL_RATE NUMBER(10,4), " +
                    "FREE_SMS NUMBER DEFAULT 0 NOT NULL, " +
                    "FREE_CALL_MINUTES NUMBER DEFAULT 0 NOT NULL, " +
                    "SMS_RATE NUMBER(10,4) DEFAULT 0.2500 NOT NULL, " +
                    // Prepaid pack fields
                    "VALIDITY_DAYS NUMBER, " +
                    "PACK_PRICE NUMBER(10,2) " +
                    ")";
            try (Statement st = conn.createStatement()) {
                st.executeUpdate(ddl);
                System.out.println("Created table PLANS");
            }
        } else {
            // Add new columns if missing (light migration path)
            addColumnIfMissing(conn, "PLANS", "PLAN_TYPE", "VARCHAR2(10) DEFAULT 'POSTPAID' NOT NULL");
            addColumnIfMissing(conn, "PLANS", "VALIDITY_DAYS", "NUMBER");
            addColumnIfMissing(conn, "PLANS", "PACK_PRICE", "NUMBER(10,2)");
            addColumnIfMissing(conn, "PLANS", "FREE_SMS", "NUMBER DEFAULT 0 NOT NULL");
            addColumnIfMissing(conn, "PLANS", "FREE_CALL_MINUTES", "NUMBER DEFAULT 0 NOT NULL");
            addColumnIfMissing(conn, "PLANS", "SMS_RATE", "NUMBER(10,4) DEFAULT 0.2500 NOT NULL");
            addColumnIfMissing(conn, "PLANS", "CALL_RATE", "NUMBER(10,4) DEFAULT 0.7500 NOT NULL");
            addColumnIfMissing(conn, "PLANS", "MONTHLY_RENT", "NUMBER(10,2) DEFAULT 0 NOT NULL");
        }
    }

    private static void ensureCustomersTable(Connection conn) throws SQLException {
        if (!tableExists(conn, "CUSTOMERS")) {
        String ddl = "CREATE TABLE CUSTOMERS (" +
                    "CUSTOMER_ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY, " +
                    "NAME VARCHAR2(100) NOT NULL, " +
                    "PHONE_NUMBER VARCHAR2(20) NOT NULL, " +
                    "ADDRESS VARCHAR2(200), " +
            // New: account type PREPAID/POSTPAID (default POSTPAID for backward compat)
            "ACCOUNT_TYPE VARCHAR2(10) DEFAULT 'POSTPAID' NOT NULL, " +
                    "PLAN_ID NUMBER, " +
                    "CONSTRAINT UQ_CUSTOMERS_PHONE UNIQUE (PHONE_NUMBER), " +
                    "CONSTRAINT FK_CUSTOMERS_PLAN FOREIGN KEY (PLAN_ID) REFERENCES PLANS(PLAN_ID)" +
                    ")";
            try (Statement st = conn.createStatement()) {
                st.executeUpdate(ddl);
                System.out.println("Created table CUSTOMERS");
            }
        } else {
            // Migrations for existing schema
            dropColumnIfExists(conn, "CUSTOMERS", "PASSWORD");
            addColumnIfMissing(conn, "CUSTOMERS", "ACCOUNT_TYPE", "VARCHAR2(10) DEFAULT 'POSTPAID' NOT NULL");
            ensureUniqueConstraint(conn, "CUSTOMERS", "UQ_CUSTOMERS_PHONE", "PHONE_NUMBER");
        }
    }

    private static void dropColumnIfExists(Connection conn, String table, String column) {
        String check = "SELECT COUNT(*) FROM USER_TAB_COLUMNS WHERE TABLE_NAME = ? AND COLUMN_NAME = ?";
        try (PreparedStatement ps = conn.prepareStatement(check)) {
            ps.setString(1, table.toUpperCase());
            ps.setString(2, column.toUpperCase());
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next() && rs.getInt(1) > 0) {
                    String alter = "ALTER TABLE " + table + " DROP COLUMN " + column;
                    try (Statement st = conn.createStatement()) {
                        st.executeUpdate(alter);
                        System.out.println("Dropped column " + column + " from " + table);
                    }
                }
            }
        } catch (SQLException e) {
            System.out.println("(Non-fatal) Column drop failed: " + e.getMessage());
        }
    }

    private static void addColumnIfMissing(Connection conn, String table, String column, String definition) {
        String check = "SELECT COUNT(*) FROM USER_TAB_COLUMNS WHERE TABLE_NAME = ? AND COLUMN_NAME = ?";
        try (PreparedStatement ps = conn.prepareStatement(check)) {
            ps.setString(1, table.toUpperCase());
            ps.setString(2, column.toUpperCase());
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next() && rs.getInt(1) == 0) {
                    String alter = "ALTER TABLE " + table + " ADD (" + column + " " + definition + ")";
                    try (Statement st = conn.createStatement()) {
                        st.executeUpdate(alter);
                        System.out.println("Added column " + column + " to " + table);
                    }
                }
            }
        } catch (SQLException e) {
            System.out.println("(Non-fatal) Column check/add failed: " + e.getMessage());
        }
    }

    private static void ensureUniqueConstraint(Connection conn, String table, String constraint, String column) {
        String sql = "SELECT COUNT(*) FROM USER_CONSTRAINTS WHERE TABLE_NAME = ? AND CONSTRAINT_NAME = ?";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setString(1, table.toUpperCase());
            ps.setString(2, constraint.toUpperCase());
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next() && rs.getInt(1) == 0) {
                    String alter = "ALTER TABLE " + table + " ADD CONSTRAINT " + constraint + " UNIQUE (" + column + ")";
                    try (Statement st = conn.createStatement()) {
                        st.executeUpdate(alter);
                        System.out.println("Added unique constraint " + constraint + " on " + table + ".");
                    }
                }
            }
        } catch (SQLException e) {
            System.out.println("(Non-fatal) Unique constraint add failed: " + e.getMessage());
        }
    }

    private static void ensureBillingTable(Connection conn) throws SQLException {
        if (tableExists(conn, "BILLING")) return;
        String ddl = "CREATE TABLE BILLING (" +
                "BILL_ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY, " +
                "CUSTOMER_ID NUMBER NOT NULL, " +
                "AMOUNT NUMBER(10,2) NOT NULL, " +
                "BILL_DATE DATE DEFAULT SYSDATE NOT NULL, " +
                "CONSTRAINT FK_BILLING_CUSTOMER FOREIGN KEY (CUSTOMER_ID) REFERENCES CUSTOMERS(CUSTOMER_ID) ON DELETE CASCADE" +
                ")";
        try (Statement st = conn.createStatement()) {
            st.executeUpdate(ddl);
            System.out.println("Created table BILLING");
        }
    }

    // Tracks per-month aggregated usage so free allowances can be applied.
    private static void ensureUsageTable(Connection conn) throws SQLException {
        if (tableExists(conn, "CUSTOMER_USAGE")) {
            // Light migration: add new chargeable tracking columns if missing
            addColumnIfMissing(conn, "CUSTOMER_USAGE", "CHARGEABLE_CALL_MINUTES", "NUMBER DEFAULT 0 NOT NULL");
            addColumnIfMissing(conn, "CUSTOMER_USAGE", "CHARGEABLE_SMS", "NUMBER DEFAULT 0 NOT NULL");
            return;
        }
        String ddl = "CREATE TABLE CUSTOMER_USAGE (" +
                "USAGE_ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY, " +
                "CUSTOMER_ID NUMBER NOT NULL, " +
                "BILLING_MONTH VARCHAR2(6) NOT NULL, " +
                "USED_CALL_MINUTES NUMBER DEFAULT 0 NOT NULL, " +
                "USED_SMS NUMBER DEFAULT 0 NOT NULL, " +
                "CHARGEABLE_CALL_MINUTES NUMBER DEFAULT 0 NOT NULL, " +
                "CHARGEABLE_SMS NUMBER DEFAULT 0 NOT NULL, " +
                "CONSTRAINT UQ_CUST_MONTH UNIQUE (CUSTOMER_ID, BILLING_MONTH), " +
                "CONSTRAINT FK_USAGE_CUSTOMER FOREIGN KEY (CUSTOMER_ID) REFERENCES CUSTOMERS(CUSTOMER_ID) ON DELETE CASCADE" +
                ")";
        try (Statement st = conn.createStatement()) {
            st.executeUpdate(ddl);
            System.out.println("Created table CUSTOMER_USAGE");
        }
    }

    // PREPAID recharge transactions and validity tracking
    private static void ensureRechargesTable(Connection conn) throws SQLException {
        if (tableExists(conn, "RECHARGES")) return;
        String ddl = "CREATE TABLE RECHARGES (" +
                "RECHARGE_ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY, " +
                "CUSTOMER_ID NUMBER NOT NULL, " +
                "PLAN_ID NUMBER NOT NULL, " +
                "AMOUNT NUMBER(10,2) NOT NULL, " +
                "PAYMENT_METHOD VARCHAR2(30) NOT NULL, " +
                "RECHARGE_DATE DATE DEFAULT SYSDATE NOT NULL, " +
                "VALID_FROM DATE NOT NULL, " +
                "VALID_TO DATE NOT NULL, " +
                "CONSTRAINT FK_RECHARGE_CUSTOMER FOREIGN KEY (CUSTOMER_ID) REFERENCES CUSTOMERS(CUSTOMER_ID) ON DELETE CASCADE, " +
                "CONSTRAINT FK_RECHARGE_PLAN FOREIGN KEY (PLAN_ID) REFERENCES PLANS(PLAN_ID) ON DELETE CASCADE" +
                ")";
        try (Statement st = conn.createStatement()) {
            st.executeUpdate(ddl);
            System.out.println("Created table RECHARGES");
        }
    }

    // ===== Spam/Fraud reporting support (used by CustomerService.reportSpam and auth checks) =====
    private static void ensureSpamFraudTables(Connection conn) throws SQLException {
        if (!tableExists(conn, "SPAM_REPORTS")) {
            String ddl = "CREATE TABLE SPAM_REPORTS (" +
                    "REPORT_ID NUMBER PRIMARY KEY, " +
                    "CUSTOMER_ID NUMBER NOT NULL, " +
                    "REPORTED_NUMBER VARCHAR2(20) NOT NULL, " +
                    "REPORTED_AT DATE DEFAULT SYSDATE NOT NULL, " +
                    "CONSTRAINT FK_SPAM_REPORT_CUSTOMER FOREIGN KEY (CUSTOMER_ID) REFERENCES CUSTOMERS(CUSTOMER_ID) ON DELETE CASCADE" +
                    ")";
            try (Statement st = conn.createStatement()) { st.executeUpdate(ddl); System.out.println("Created table SPAM_REPORTS"); }
        }
        ensureSequence(conn, "REPORT_SEQ");

        if (!tableExists(conn, "FRAUD_NUMBERS")) {
            String ddl = "CREATE TABLE FRAUD_NUMBERS (" +
                    "ID NUMBER PRIMARY KEY, " +
                    "PHONE_NUMBER VARCHAR2(20) UNIQUE NOT NULL, " +
                    "REASON VARCHAR2(200), " +
                    "FLAGGED_AT DATE DEFAULT SYSDATE NOT NULL" +
                    ")";
            try (Statement st = conn.createStatement()) { st.executeUpdate(ddl); System.out.println("Created table FRAUD_NUMBERS"); }
        }
        ensureSequence(conn, "FRAUD_SEQ");
    }

    private static boolean sequenceExists(Connection conn, String seqName) throws SQLException {
        String sql = "SELECT COUNT(*) FROM USER_SEQUENCES WHERE SEQUENCE_NAME = ?";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setString(1, seqName.toUpperCase());
            try (ResultSet rs = ps.executeQuery()) { return rs.next() && rs.getInt(1) > 0; }
        }
    }

    private static void ensureSequence(Connection conn, String seqName) throws SQLException {
        if (sequenceExists(conn, seqName)) return;
        try (Statement st = conn.createStatement()) {
            st.executeUpdate("CREATE SEQUENCE " + seqName + " START WITH 1 INCREMENT BY 1 NOCACHE");
            System.out.println("Created sequence " + seqName);
        }
    }

    // ===== Support Tickets schema =====
    private static void ensureSupportTicketsTable(Connection conn) throws SQLException {
        if (!tableExists(conn, "SUPPORT_TICKETS")) {
            String ddl = "CREATE TABLE SUPPORT_TICKETS (" +
                    "TICKET_ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY, " +
                    "CUSTOMER_ID NUMBER NOT NULL, " +
                    "SUBJECT VARCHAR2(150) NOT NULL, " +
                    "CATEGORY VARCHAR2(30) DEFAULT 'GENERAL' NOT NULL, " +
                    "ISSUE_DESCRIPTION VARCHAR2(1000) NOT NULL, " +
                    "PRIORITY VARCHAR2(10) DEFAULT 'MEDIUM' NOT NULL, " +
                    "STATUS VARCHAR2(15) DEFAULT 'OPEN' NOT NULL, " +
                    "ASSIGNED_TO VARCHAR2(60), " +
                    "CREATED_AT DATE DEFAULT SYSDATE NOT NULL, " +
                    "UPDATED_AT DATE DEFAULT SYSDATE NOT NULL, " +
                    "CONSTRAINT FK_TICKET_CUSTOMER FOREIGN KEY (CUSTOMER_ID) REFERENCES CUSTOMERS(CUSTOMER_ID) ON DELETE CASCADE" +
                    ")";
            try (Statement st = conn.createStatement()) { st.executeUpdate(ddl); System.out.println("Created table SUPPORT_TICKETS"); }
        } else {
            // migrations
            addColumnIfMissing(conn, "SUPPORT_TICKETS", "SUBJECT", "VARCHAR2(150) DEFAULT 'Support Ticket' NOT NULL");
            addColumnIfMissing(conn, "SUPPORT_TICKETS", "CATEGORY", "VARCHAR2(30) DEFAULT 'GENERAL' NOT NULL");
            addColumnIfMissing(conn, "SUPPORT_TICKETS", "PRIORITY", "VARCHAR2(10) DEFAULT 'MEDIUM' NOT NULL");
            addColumnIfMissing(conn, "SUPPORT_TICKETS", "STATUS", "VARCHAR2(15) DEFAULT 'OPEN' NOT NULL");
            addColumnIfMissing(conn, "SUPPORT_TICKETS", "ASSIGNED_TO", "VARCHAR2(60)");
            addColumnIfMissing(conn, "SUPPORT_TICKETS", "CREATED_AT", "DATE DEFAULT SYSDATE NOT NULL");
            addColumnIfMissing(conn, "SUPPORT_TICKETS", "UPDATED_AT", "DATE DEFAULT SYSDATE NOT NULL");
        }
    }

    private static void ensureTicketCommentsTable(Connection conn) throws SQLException {
        if (tableExists(conn, "TICKET_COMMENTS")) return;
        String ddl = "CREATE TABLE TICKET_COMMENTS (" +
                "COMMENT_ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY, " +
                "TICKET_ID NUMBER NOT NULL, " +
                "AUTHOR_TYPE VARCHAR2(10) NOT NULL, " +
                "COMMENT_TEXT VARCHAR2(1000) NOT NULL, " +
                "CREATED_AT DATE DEFAULT SYSDATE NOT NULL, " +
                "CONSTRAINT FK_COMMENT_TICKET FOREIGN KEY (TICKET_ID) REFERENCES SUPPORT_TICKETS(TICKET_ID) ON DELETE CASCADE" +
                ")";
        try (Statement st = conn.createStatement()) {
            st.executeUpdate(ddl);
            System.out.println("Created table TICKET_COMMENTS");
        }
    }

    private static void seedPlans(Connection conn) throws SQLException {
        if (!tableExists(conn, "PLANS")) return; // safety
        if (!isEmpty(conn, "PLANS")) return; // already seeded
        // Insert both POSTPAID and PREPAID plans
        String insert = "INSERT INTO PLANS (PLAN_NAME, PLAN_TYPE, MONTHLY_RENT, CALL_RATE, FREE_SMS, FREE_CALL_MINUTES, SMS_RATE, VALIDITY_DAYS, PACK_PRICE) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)";
        try (PreparedStatement ps = conn.prepareStatement(insert)) {
            // Postpaid: name, type, monthly, callRate, freeSms, freeMin, smsRate, validityDays, packPrice
            Object[][] data = new Object[][] {
                    {"Basic Postpaid", "POSTPAID", 199.00, 0.90, 100, 100, 0.25, null, null},
                    {"Standard Postpaid", "POSTPAID", 399.00, 0.75, 250, 300, 0.20, null, null},
                    {"Premium Postpaid", "POSTPAID", 699.00, 0.60, 500, 800, 0.15, null, null},
                    // Prepaid: unlimited calls/SMS with validity, price; rates and monthly rent unused
                    {"Prepaid 28 Days Unlimited", "PREPAID", 0.0, 0.0, 0, 0, 0.0, 28, 249.00},
                    {"Prepaid 56 Days Unlimited", "PREPAID", 0.0, 0.0, 0, 0, 0.0, 56, 449.00},
                    {"Prepaid 84 Days Unlimited", "PREPAID", 0.0, 0.0, 0, 0, 0.0, 84, 599.00}
            };
            for (Object[] row : data) {
                ps.setString(1, (String) row[0]);
                ps.setString(2, (String) row[1]);
                // monthly rent
                if (row[2] == null) ps.setNull(3, java.sql.Types.NUMERIC); else ps.setDouble(3, (Double) row[2]);
                // call rate
                if (row[3] == null) ps.setNull(4, java.sql.Types.NUMERIC); else ps.setDouble(4, (Double) row[3]);
                // free sms
                ps.setInt(5, (Integer) row[4]);
                // free call minutes
                ps.setInt(6, (Integer) row[5]);
                // sms rate
                if (row[6] == null) ps.setNull(7, java.sql.Types.NUMERIC); else ps.setDouble(7, (Double) row[6]);
                // validity days
                if (row[7] == null) ps.setNull(8, java.sql.Types.NUMERIC); else ps.setInt(8, (Integer) row[7]);
                // pack price
                if (row[8] == null) ps.setNull(9, java.sql.Types.NUMERIC); else ps.setDouble(9, (Double) row[8]);
                ps.addBatch();
            }
            ps.executeBatch();
            System.out.println("Seeded PLANS table with sample data.");
        }
    }
}
